//                                                   
//  Devices.cpp                                      
//  SMCSuperIO                                       
//                                                   
//  Copyright Â© 2016-2019 joedm. All rights reserved.
//                                                   
//  This is an autogenerated file!                   
//  Please avoid any modifications!                  
//                                                   

#include "Devices.hpp"
#include "NuvotonDevice.hpp"
#include "FintekDevice.hpp"
#include "ITEDevice.hpp"
#include "WinbondDevice.hpp"
#include "ECDeviceNUC.hpp"

class GeneratedECDevice_0 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 3;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V9_FAN1_U16);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V9_FAN2_U16);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V9_FAN3_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		switch (index) {
			case 0: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_FAN1_TYPE_U8));
			case 1: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_FAN2_TYPE_U8));
			case 2: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_FAN3_TYPE_U8));
			default: break;
		}
		return nullptr;
	}

public:
	uint8_t getVoltageCount() override {
		return 5;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_VOLTAGE1_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_VOLTAGE2_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_VOLTAGE3_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_VOLTAGE4_U16) / 1000;
			case 4: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_VOLTAGE5_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		switch (index) {
			case 0: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE1_TYPE_U8));
			case 1: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE2_TYPE_U8));
			case 2: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE3_TYPE_U8));
			case 3: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE4_TYPE_U8));
			case 4: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE5_TYPE_U8));
			default: break;
		}
		return nullptr;
	}

protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE1_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE2_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE3_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE4_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 3)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_VOLTAGE5_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 4)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 3;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_TEMP1_U8) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_TEMP2_U8) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V9_TEMP3_U8) / 1000;
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		switch (index) {
			case 0: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_TEMP1_TYPE_U8));
			case 1: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_TEMP2_TYPE_U8));
			case 2: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_TEMP3_TYPE_U8));
			default: break;
		}
		return nullptr;
	}

protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_TEMP1_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_TEMP2_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_V9_TEMP3_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
	}

};

class Device_Intel_EC_V9 final : public GeneratedECDevice_0 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V9") == 0)
			return new Device_Intel_EC_V9();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedNuvotonDevice_1 : public Nuvoton::NuvotonDevice {
public:
	uint8_t getTachometerCount() override {
		return 3;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead6776(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[3] = {
		"SYSFAN",
		"CPUFAN",
		"AUXFAN0",
	};
public:
	uint8_t getVoltageCount() override {
		return 10;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead6775(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[10] = {
		"CPUVCORE",
		"VIN1",
		"AVSB",
		"3VCC",
		"VIN0",
		"VIN2",
		"VIN4",
		"3VSB",
		"VBAT",
		"VTT",
	};

};

class Device_0xB470 final : public GeneratedNuvotonDevice_1 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xB470)
			return new Device_0xB470();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6771F";
	}

};

class GeneratedFintekDevice_2 : public Fintek::FintekDevice {
public:
	uint8_t getTachometerCount() override {
		return 3;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[3] = {
		"FAN1",
		"FAN2",
		"FAN3",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead71808E(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"VCC3V",
		"Vcore",
		"V2",
		"V3",
		"V4",
		"V5",
		"Reserved",
		"VSB3V",
		"VBAT",
	};

};

class Device_0x0901 final : public GeneratedFintekDevice_2 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0901)
			return new Device_0x0901();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71808E";
	}

};

class GeneratedWinbondDevice_3 : public Winbond::WinbondDevice {
public:
	uint8_t getTachometerCount() override {
		return 3;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[3] = {
		"SYSFAN",
		"CPUFAN0",
		"AUXFAN0",
	};
public:
	uint8_t getVoltageCount() override {
		return 7;
	}

	float updateVoltage(uint8_t index) override {
		return voltageReadVrmCheck(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[7] = {
		"CPUVCORE",
		"VIN0",
		"AVCC",
		"3VCC",
		"VIN1",
		"VSB",
		"VBAT",
	};

};

class Device_0x5217 final : public GeneratedWinbondDevice_3 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x5217)
			return new Device_0x5217();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627HF";
	}

};

class Device_0x523A final : public GeneratedWinbondDevice_3 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x523A)
			return new Device_0x523A();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627HF";
	}

};

class Device_0x5241 final : public GeneratedWinbondDevice_3 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x5241)
			return new Device_0x5241();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627HF";
	}

};

class Device_0x8280 final : public GeneratedWinbondDevice_3 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0x8280)
			return new Device_0x8280();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627THF";
	}

};

class Device_0x8541 final : public GeneratedWinbondDevice_3 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8541)
			return new Device_0x8541();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83687THF";
	}

};

class GeneratedECDevice_4 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_VB_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 5;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_VB_CPU_CORE_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_VB_DIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_VB_DC_IN_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_VB_GPU_CORE_U16) / 1000;
			case 4: return (float)readBigWordMMIO(EC::B_NUC_EC_VB_DC_IN_ALT_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[5] = {
		"CPUVCORE",
		"VDIMM",
		"VIN",
		"VGPU",
		"VINALT",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVD0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 6;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_VB_CPU_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_VB_GPU_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_VB_PCH_TEMP_U8);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_VB_CPU_VR_TEMP_U8);
			case 4: return readBigWordMMIO(EC::B_NUC_EC_VB_GPU_VR_U8);
			case 5: return readBigWordMMIO(EC::B_NUC_EC_VB_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[6] = {
		"TCPU",
		"TGPU",
		"TPCH",
		"TVRMCPU",
		"TVRMGPU",
		"TMLB",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTC0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTG0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
	}

};

class Device_Intel_EC_VB final : public GeneratedECDevice_4 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_VB") == 0)
			return new Device_Intel_EC_VB();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedITEDevice_5 : public ITE::ITEDevice {
public:
	uint8_t getTachometerCount() override {
		return 3;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead8bit(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[3] = {
		"FAN1",
		"FAN2",
		"FAN3",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageReadOld(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"VIN0",
		"VIN1",
		"VIN2",
		"VIN3",
		"VIN4",
		"VIN5",
		"VIN6",
		"VIN7",
		"VBAT",
	};

};

class Device_0x8705 final : public GeneratedITEDevice_5 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8705)
			return new Device_0x8705();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8705F";
	}

};

class Device_0x8712 final : public GeneratedITEDevice_5 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8712)
			return new Device_0x8712();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8712F";
	}

};

class GeneratedITEDevice_6 : public ITE::ITEDevice {
public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"FAN1",
		"FAN2",
		"FAN3",
		"FAN4",
		"FAN5",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"VIN0",
		"VIN1",
		"VIN2",
		"VIN3",
		"VIN4",
		"VIN5",
		"VIN6",
		"VIN7",
		"VBAT",
	};

};

class Device_0x8721 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8721)
			return new Device_0x8721();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8721F";
	}

};

class Device_0x8726 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8726)
			return new Device_0x8726();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8726F";
	}

};

class Device_0x8620 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8620)
			return new Device_0x8620();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8620E";
	}

};

class Device_0x8628 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8628)
			return new Device_0x8628();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8628E";
	}

};

class Device_0x8686 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8686)
			return new Device_0x8686();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8686E";
	}

};

class Device_0x8728 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8728)
			return new Device_0x8728();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8728F";
	}

};

class Device_0x8752 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8752)
			return new Device_0x8752();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8752F";
	}

};

class Device_0x8771 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8771)
			return new Device_0x8771();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8771E";
	}

};

class Device_0x8772 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8772)
			return new Device_0x8772();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8772E";
	}

};

class Device_0x8792 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8792)
			return new Device_0x8792();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8792E";
	}

};

class Device_0x8688 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8688)
			return new Device_0x8688();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8688E";
	}

};

class Device_0x8795 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8795)
			return new Device_0x8795();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8795E";
	}

};

class Device_0x8665 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8665)
			return new Device_0x8665();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8665E";
	}

};

class Device_0x8613 final : public GeneratedITEDevice_6 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8613)
			return new Device_0x8613();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8613E";
	}

};

class GeneratedECDevice_7 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V8_CPU_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 4;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V8_VCORE_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V8_VDIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V8_VCCIO_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_V8_V5VSB_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[4] = {
		"CPUVCORE",
		"VDIMM",
		"VIO",
		"VDD5",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyV50R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 3)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 4;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V8_DIMM_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V8_DIMM_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V8_VR_TEMP_U8);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_V8_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[4] = {
		"TPCH",
		"TDIMM",
		"TVRM",
		"TMLB",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTM0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
	}

};

class Device_Intel_EC_V8 final : public GeneratedECDevice_7 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V8") == 0)
			return new Device_Intel_EC_V8();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedNuvotonDevice_8 : public Nuvoton::NuvotonDevice {
public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"SYSFAN",
		"CPUFAN",
		"AUXFAN0",
		"AUXFAN1",
		"AUXFAN2",
	};
public:
	uint8_t getVoltageCount() override {
		return 15;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[15] = {
		"CPUVCORE",
		"VIN1",
		"AVSB",
		"3VCC",
		"VIN0",
		"VIN8",
		"VIN4",
		"3VSB",
		"VBAT",
		"VTT",
		"VIN5",
		"VIN6",
		"VIN2",
		"VIN3",
		"VIN7",
	};

};

class Device_0xC560 final : public GeneratedNuvotonDevice_8 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xC560)
			return new Device_0xC560();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6779D";
	}

};

class GeneratedITEDevice_9 : public ITE::ITEDevice {
public:
	uint8_t getTachometerCount() override {
		return 2;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerReadEC(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[2] = {
		"FAN1",
		"FAN2",
	};
public:
	uint8_t getVoltageCount() override {
		return 0;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[0] = {
	};

};

class Device_0x8987 final : public GeneratedITEDevice_9 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8987)
			return new Device_0x8987();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0xFF;
	}

	const char* getModelName() override {
		return "ITE IT8987";
	}

};

class GeneratedNuvotonDevice_10 : public Nuvoton::NuvotonDevice {
	void onPowerOn() override {
		onPowerOn679xx();
	}

public:
	uint8_t getTachometerCount() override {
		return 7;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[7] = {
		"SYSFAN",
		"CPUFAN",
		"AUXFAN0",
		"AUXFAN1",
		"AUXFAN2",
		"AUXFAN3",
		"AUXFAN4",
	};
public:
	uint8_t getVoltageCount() override {
		return 16;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[16] = {
		"CPUVCORE",
		"VIN1",
		"AVSB",
		"3VCC",
		"VIN0",
		"VIN8",
		"VIN4",
		"3VSB",
		"VBAT",
		"VTT",
		"VIN5",
		"VIN6",
		"VIN2",
		"VIN3",
		"VIN7",
		"VIN9",
	};

};

class Device_0xD423 final : public GeneratedNuvotonDevice_10 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD423)
			return new Device_0xD423();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6796D";
	}

};

class Device_0xD451 final : public GeneratedNuvotonDevice_10 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD451)
			return new Device_0xD451();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6797D";
	}

};

class Device_0xD428 final : public GeneratedNuvotonDevice_10 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD428)
			return new Device_0xD428();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6798D";
	}

};

class Device_0xD802 final : public GeneratedNuvotonDevice_10 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD802)
			return new Device_0xD802();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6799D";
	}

};

class Device_0xD42A final : public GeneratedNuvotonDevice_10 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD42A)
			return new Device_0xD42A();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6796D-E";
	}

};

class Device_0xD42B final : public GeneratedNuvotonDevice_10 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD42B)
			return new Device_0xD42B();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT679BD";
	}

};

class GeneratedECDevice_11 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 6;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_VA_FAN1_U16);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_VA_FAN2_U16);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_VA_FAN3_U16);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_VA_FAN4_U16);
			case 4: return readBigWordMMIO(EC::B_NUC_EC_VA_FAN5_U16);
			case 5: return readBigWordMMIO(EC::B_NUC_EC_VA_FAN6_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		switch (index) {
			case 0: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_FAN1_TYPE_U8));
			case 1: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_FAN2_TYPE_U8));
			case 2: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_FAN3_TYPE_U8));
			case 3: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_FAN4_TYPE_U8));
			case 4: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_FAN5_TYPE_U8));
			case 5: return getTachometerNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_FAN6_TYPE_U8));
			default: break;
		}
		return nullptr;
	}

public:
	uint8_t getVoltageCount() override {
		return 6;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_VOLTAGE1_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_VOLTAGE2_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_VOLTAGE3_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_VOLTAGE4_U16) / 1000;
			case 4: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_VOLTAGE5_U16) / 1000;
			case 5: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_VOLTAGE6_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		switch (index) {
			case 0: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE1_TYPE_U8));
			case 1: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE2_TYPE_U8));
			case 2: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE3_TYPE_U8));
			case 3: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE4_TYPE_U8));
			case 4: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE5_TYPE_U8));
			case 5: return getVoltageNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE6_TYPE_U8));
			default: break;
		}
		return nullptr;
	}

protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE1_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE2_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE3_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE4_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 3)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE5_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 4)));
		VirtualSMCAPI::addKey(getVoltageSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_VOLTAGE6_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 5)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 5;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_TEMP1_U8) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_TEMP2_U8) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_TEMP3_U8) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_TEMP4_U8) / 1000;
			case 4: return (float)readBigWordMMIO(EC::B_NUC_EC_VA_TEMP5_U8) / 1000;
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		switch (index) {
			case 0: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP1_TYPE_U8));
			case 1: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP2_TYPE_U8));
			case 2: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP3_TYPE_U8));
			case 3: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP4_TYPE_U8));
			case 4: return getTemperatureNameForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP5_TYPE_U8));
			default: break;
		}
		return nullptr;
	}

protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP1_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP2_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP3_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP4_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 3)));
		VirtualSMCAPI::addKey(getTemperatureSMCKeyForType(readBigWordMMIOCached(EC::B_NUC_EC_VA_TEMP5_TYPE_U8)), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 4)));
	}

};

class Device_Intel_EC_VA final : public GeneratedECDevice_11 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_VA") == 0)
			return new Device_Intel_EC_VA();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedECDevice_12 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V2_CPU_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 4;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V2_CPU1_INPUT_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V2_SDRAM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V2_V33_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_V2_V5_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[4] = {
		"CPUVCORE",
		"VDRAM",
		"VDD33",
		"VDD5",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVR3R, vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(KeyV50R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 3)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 2;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V2_VR_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V2_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[2] = {
		"TVR",
		"TMLB",
	};

};

class Device_Intel_EC_V2 final : public GeneratedECDevice_12 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V2") == 0)
			return new Device_Intel_EC_V2();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedNuvotonDevice_13 : public Nuvoton::NuvotonDevice {
	void onPowerOn() override {
		voltageMapping6683();
	}

public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead6683(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"CPUFAN",
		"SYSFAN",
		"AUXFAN0",
		"AUXFAN1",
		"AUXFAN2",
	};
public:
	uint8_t getVoltageCount() override {
		return 23;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead6683(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[23] = {
		"3VCC",
		"3VSB",
		"AVSB",
		"VTT",
		"VBAT",
		"VREF",
		"VIN0",
		"VIN1",
		"VIN2",
		"VIN3",
		"VIN4",
		"VIN5",
		"VIN6",
		"VIN7",
		"VIN8",
		"VIN9",
		"VIN10",
		"VIN11",
		"VIN12",
		"VIN13",
		"VIN14",
		"VIN15",
		"VIN16",
	};

};

class Device_0xC730 final : public GeneratedNuvotonDevice_13 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xC730)
			return new Device_0xC730();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6683D";
	}

};

class Device_0xD440 final : public GeneratedNuvotonDevice_13 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xD440)
			return new Device_0xD440();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6686D";
	}

};

class Device_0xD590 final : public GeneratedNuvotonDevice_13 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xD590)
			return new Device_0xD590();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6687D";
	}

};

class GeneratedWinbondDevice_14 : public Winbond::WinbondDevice {
public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"SYSFAN",
		"CPUFAN0",
		"AUXFAN0",
		"CPUFAN1",
		"AUXFAN1",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"CPUVCORE",
		"VIN0",
		"AVCC",
		"3VCC",
		"VIN1",
		"VIN2",
		"VIN3",
		"VSB",
		"VBAT",
	};

};

class Device_0xA020 final : public GeneratedWinbondDevice_14 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xA020)
			return new Device_0xA020();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627DHG";
	}

};

class Device_0x8860 final : public GeneratedWinbondDevice_14 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0x8860)
			return new Device_0x8860();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627EHG";
	}

};

class Device_0xB070 final : public GeneratedWinbondDevice_14 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xB070)
			return new Device_0xB070();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627DHGP";
	}

};

class Device_0xA510 final : public GeneratedWinbondDevice_14 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xA510)
			return new Device_0xA510();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83667HG";
	}

};

class Device_0xB350 final : public GeneratedWinbondDevice_14 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xB350)
			return new Device_0xB350();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83667HGB";
	}

};

class GeneratedFintekDevice_15 : public Fintek::FintekDevice {
public:
	uint8_t getTachometerCount() override {
		return 3;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[3] = {
		"FAN1",
		"FAN2",
		"FAN3",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"VCC3V",
		"Vcore",
		"V2",
		"V3",
		"V4",
		"V5",
		"V6",
		"VSB3V",
		"VBAT",
	};

};

class Device_0x0601 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0601)
			return new Device_0x0601();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71862";
	}

};

class Device_0x1106 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x1106)
			return new Device_0x1106();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71868A";
	}

};

class Device_0x0814 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0814)
			return new Device_0x0814();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71869";
	}

};

class Device_0x1007 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x1007)
			return new Device_0x1007();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71869A";
	}

};

class Device_0x1005 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x1005)
			return new Device_0x1005();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71889AD";
	}

};

class Device_0x0909 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0909)
			return new Device_0x0909();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71889ED";
	}

};

class Device_0x0723 final : public GeneratedFintekDevice_15 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0723)
			return new Device_0x0723();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71889F";
	}

};

class GeneratedECDevice_16 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V4_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 3;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V4_CPU_CORE_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V4_DIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V4_DC_IN_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[3] = {
		"CPUVCORE",
		"VDIMM",
		"VIN",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVD0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 5;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V4_CPU_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V4_GPU_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V4_PCH_TEMP_U8);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_V4_CPU_VR_TEMP_U8);
			case 4: return readBigWordMMIO(EC::B_NUC_EC_V4_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[5] = {
		"TCPU",
		"TGPU",
		"TPCH",
		"TVRMCPU",
		"TMLB",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTC0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTG0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
	}

};

class Device_Intel_EC_V4 final : public GeneratedECDevice_16 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V4") == 0)
			return new Device_Intel_EC_V4();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedITEDevice_17 : public ITE::ITEDevice {
public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"FAN1",
		"FAN2",
		"FAN3",
		"FAN4",
		"FAN5",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageReadOld(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"VIN0",
		"VIN1",
		"VIN2",
		"VIN3",
		"VIN4",
		"VIN5",
		"VIN6",
		"VIN7",
		"VBAT",
	};

};

class Device_0x8716 final : public GeneratedITEDevice_17 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8716)
			return new Device_0x8716();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8716F";
	}

};

class Device_0x8718 final : public GeneratedITEDevice_17 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8718)
			return new Device_0x8718();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8718F";
	}

};

class Device_0x8720 final : public GeneratedITEDevice_17 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x8720)
			return new Device_0x8720();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "ITE IT8720F";
	}

};

class GeneratedFintekDevice_18 : public Fintek::FintekDevice {
public:
	uint8_t getTachometerCount() override {
		return 4;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[4] = {
		"FAN1",
		"FAN2",
		"FAN3",
		"FAN4",
	};
public:
	uint8_t getVoltageCount() override {
		return 9;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[9] = {
		"VCC3V",
		"Vcore",
		"V2",
		"V3",
		"V4",
		"V5",
		"V6",
		"VSB3V",
		"VBAT",
	};

};

class Device_0x0541 final : public GeneratedFintekDevice_18 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0541)
			return new Device_0x0541();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x04;
	}

	const char* getModelName() override {
		return "Fintek F71882";
	}

};

class GeneratedECDevice_19 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V6_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 3;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V6_CPU_CORE_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V6_DIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V6_DC_IN_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[3] = {
		"CPUVCORE",
		"VDIMM",
		"VIN",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVD0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 5;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V6_CPU_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V6_GPU_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V6_PCH_TEMP_U8);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_V6_CPU_VR_TEMP_U8);
			case 4: return readBigWordMMIO(EC::B_NUC_EC_V6_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[5] = {
		"TCPU",
		"TGPU",
		"TPCH",
		"TVRMCPU",
		"TMLB",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTC0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTG0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
	}

};

class Device_Intel_EC_V6 final : public GeneratedECDevice_19 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V6") == 0)
			return new Device_Intel_EC_V6();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedECDevice_20 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V1_SLOT_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 5;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V1_VCORE_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V1_VDIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V1_VIN_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_V1_VCC3_U16) / 1000;
			case 4: return (float)readBigWordMMIO(EC::B_NUC_EC_V1_VCCIO_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[5] = {
		"CPUVCORE",
		"VDIMM",
		"VIN",
		"VDD33",
		"VIO",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVD0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(KeyVR3R, vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 3)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 4;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V1_CPU_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V1_PCH_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V1_DIMM_TEMP_U8);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_V1_HDD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[4] = {
		"TCPU",
		"TPCH",
		"TDIMM",
		"THHD",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTC0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyTM0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(KeyTH0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 3)));
	}

};

class Device_Intel_EC_V1 final : public GeneratedECDevice_20 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V1") == 0)
			return new Device_Intel_EC_V1();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedNuvotonDevice_21 : public Nuvoton::NuvotonDevice {
public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead6776(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"SYSFAN",
		"CPUFAN",
		"AUXFAN0",
		"AUXFAN1",
		"AUXFAN2",
	};
public:
	uint8_t getVoltageCount() override {
		return 10;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead6775(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[10] = {
		"CPUVCORE",
		"VIN1",
		"AVSB",
		"3VCC",
		"VIN0",
		"VIN2",
		"VIN4",
		"3VSB",
		"VBAT",
		"VTT",
	};

};

class Device_0xC330 final : public GeneratedNuvotonDevice_21 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0xC330)
			return new Device_0xC330();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6776F";
	}

};

class GeneratedECDevice_22 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V3_CPU_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 4;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V3_CPU1_INPUT_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V3_SDRAM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V3_V33_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_V3_CPU_IO_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[4] = {
		"CPUVCORE",
		"VDRAM",
		"VDD33",
		"VIO",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVR3R, vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 4;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V3_CPU_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V3_PCH_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V3_MEMORY_TEMP_U8);
			case 3: return readBigWordMMIO(EC::B_NUC_EC_V3_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[4] = {
		"TCPU",
		"TPCH",
		"TDRAM",
		"TMLB",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTC0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyTM0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
	}

};

class Device_Intel_EC_V3 final : public GeneratedECDevice_22 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V3") == 0)
			return new Device_Intel_EC_V3();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedNuvotonDevice_23 : public Nuvoton::NuvotonDevice {
	void onPowerOn() override {
		onPowerOn679xx();
	}

public:
	uint8_t getTachometerCount() override {
		return 6;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[6] = {
		"SYSFAN",
		"CPUFAN",
		"AUXFAN0",
		"AUXFAN1",
		"AUXFAN2",
		"AUXFAN3",
	};
public:
	uint8_t getVoltageCount() override {
		return 15;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[15] = {
		"CPUVCORE",
		"VIN1",
		"AVSB",
		"3VCC",
		"VIN0",
		"VIN8",
		"VIN4",
		"3VSB",
		"VBAT",
		"VTT",
		"VIN5",
		"VIN6",
		"VIN2",
		"VIN3",
		"VIN7",
	};

};

class Device_0xC803 final : public GeneratedNuvotonDevice_23 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xC803)
			return new Device_0xC803();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6791D";
	}

};

class Device_0xC911 final : public GeneratedNuvotonDevice_23 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xC911)
			return new Device_0xC911();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6792D";
	}

};

class Device_0xD121 final : public GeneratedNuvotonDevice_23 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD121)
			return new Device_0xD121();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6793D";
	}

};

class Device_0xD352 final : public GeneratedNuvotonDevice_23 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0xD352)
			return new Device_0xD352();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Nuvoton NCT6795D";
	}

};

class GeneratedFintekDevice_24 : public Fintek::FintekDevice {
public:
	uint8_t getTachometerCount() override {
		return 4;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[4] = {
		"FAN1",
		"FAN2",
		"FAN3",
		"FAN4",
	};
public:
	uint8_t getVoltageCount() override {
		return 0;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[0] = {
	};

};

class Device_0x0507 final : public GeneratedFintekDevice_24 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if (deviceId == 0x0507)
			return new Device_0x0507();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x02;
	}

	const char* getModelName() override {
		return "Fintek F71858";
	}

};

class GeneratedECDevice_25 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 1;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V7_CPU_FAN_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[1] = {
		"FAN",
	};
public:
	uint8_t getVoltageCount() override {
		return 5;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V7_VCORE_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V7_VDIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V7_VIN_U16) / 1000;
			case 3: return (float)readBigWordMMIO(EC::B_NUC_EC_V7_V33_U16) / 1000;
			case 4: return (float)readBigWordMMIO(EC::B_NUC_EC_V7_V5_VCC_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[5] = {
		"CPUVCORE",
		"VDIMM",
		"VIN",
		"VDD33",
		"VDD5",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVD0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
		VirtualSMCAPI::addKey(KeyVR3R, vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 3)));
		VirtualSMCAPI::addKey(KeyV50R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 4)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 3;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V7_DIMM_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V7_VR_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V7_MOTHERBOARD_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[3] = {
		"TDIMM",
		"TVRM",
		"TMLB",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTM0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
	}

};

class Device_Intel_EC_V7 final : public GeneratedECDevice_25 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V7") == 0)
			return new Device_Intel_EC_V7();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedECDevice_26 : public EC::ECDeviceNUC {
public:
	uint8_t getTachometerCount() override {
		return 2;
	}

	uint16_t updateTachometer(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V5_FAN1_U16);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V5_FAN2_U16);
			default: break;
		}
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[2] = {
		"FANCPU",
		"FANEXT",
	};
public:
	uint8_t getVoltageCount() override {
		return 3;
	}

	float updateVoltage(uint8_t index) override {
		switch (index) {
			case 0: return (float)readBigWordMMIO(EC::B_NUC_EC_V5_CPU_U16) / 1000;
			case 1: return (float)readBigWordMMIO(EC::B_NUC_EC_V5_DIMM_U16) / 1000;
			case 2: return (float)readBigWordMMIO(EC::B_NUC_EC_V5_DC_IN_U16) / 1000;
			default: break;
		}
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[3] = {
		"CPUVCORE",
		"VDIMM",
		"VIN",
	};
protected:
	void setupVoltageKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyVM0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyVD0R(0), vsmcPlugin.data, VirtualSMCAPI::valueWithFlt(0,  new VoltageKey(getSmcSuperIO(), this, 2)));
	}
public:
	uint8_t getTemperatureCount() override {
		return 3;
	}

	float updateTemperature(uint8_t index) override {
		switch (index) {
			case 0: return readBigWordMMIO(EC::B_NUC_EC_V5_CPU_TEMP_U8);
			case 1: return readBigWordMMIO(EC::B_NUC_EC_V5_PCH_TEMP_U8);
			case 2: return readBigWordMMIO(EC::B_NUC_EC_V5_MEMORY_TEMP_U8);
			default: break;
		}
		return temperatureRead(index);
	}

	const char* getTemperatureName(uint8_t index) override {
		if (index < getTemperatureCount()) {
			return temperatureNames[index];
		}
		return nullptr;
	}

private:
	const char* temperatureNames[3] = {
		"TCPU",
		"TPCH",
		"TDIMM",
	};
protected:
	void setupTemperatureKeys(VirtualSMCAPI::Plugin &vsmcPlugin) override {
		VirtualSMCAPI::addKey(KeyTC0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 0)));
		VirtualSMCAPI::addKey(KeyTP0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 1)));
		VirtualSMCAPI::addKey(KeyTM0P(0), vsmcPlugin.data, VirtualSMCAPI::valueWithSp(0, SmcKeyTypeSp78, new TemperatureKey(getSmcSuperIO(), this, 2)));
	}

};

class Device_Intel_EC_V5 final : public GeneratedECDevice_26 {
public:
	static SuperIODevice *createDevice(const char *name) {
		if (strcmp(name, "Intel_EC_V5") == 0)
			return new Device_Intel_EC_V5();
		return nullptr;
	}

	const char* getModelName() override {
		return "Intel NUC Embedded Controller";
	}

};

class GeneratedWinbondDevice_27 : public Winbond::WinbondDevice {
public:
	uint8_t getTachometerCount() override {
		return 5;
	}

	uint16_t updateTachometer(uint8_t index) override {
		return tachometerRead(index);
	}

	const char* getTachometerName(uint8_t index) override {
		if (index < getTachometerCount()) {
			return tachometerNames[index];
		}
		return nullptr;
	}

private:
	const char* tachometerNames[5] = {
		"SYSFAN",
		"CPUFAN0",
		"AUXFAN0",
		"CPUFAN1",
		"AUXFAN1",
	};
public:
	uint8_t getVoltageCount() override {
		return 10;
	}

	float updateVoltage(uint8_t index) override {
		return voltageRead(index);
	}

	const char* getVoltageName(uint8_t index) override {
		if (index < getVoltageCount()) {
			return voltageNames[index];
		}
		return nullptr;
	}

private:
	const char* voltageNames[10] = {
		"CPUVCORE",
		"VIN0",
		"AVCC",
		"3VCC",
		"VIN1",
		"VIN2",
		"VIN3",
		"VSB",
		"VBAT",
		"VIN4",
	};

};

class Device_0x8850 final : public GeneratedWinbondDevice_27 {
public:
	static SuperIODevice *createDevice(uint16_t deviceId) {
		if ((deviceId & 0xFFF0) == 0x8850)
			return new Device_0x8850();
		return nullptr;
	}

	uint8_t getLdn() override {
		return 0x0B;
	}

	const char* getModelName() override {
		return "Winbond W83627EHF";
	}

};

SuperIODevice *createDevice(uint16_t deviceId) {
	SuperIODevice *device;
	device = Device_0xB470::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0901::createDevice(deviceId);
	if (device) return device;
	device = Device_0x5217::createDevice(deviceId);
	if (device) return device;
	device = Device_0x523A::createDevice(deviceId);
	if (device) return device;
	device = Device_0x5241::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8280::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8541::createDevice(deviceId);
	if (device) return device;
	device = Device_0xC560::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD423::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD451::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD428::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD42A::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD42B::createDevice(deviceId);
	if (device) return device;
	device = Device_0xC730::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD440::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD590::createDevice(deviceId);
	if (device) return device;
	device = Device_0xA020::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8860::createDevice(deviceId);
	if (device) return device;
	device = Device_0xB070::createDevice(deviceId);
	if (device) return device;
	device = Device_0xA510::createDevice(deviceId);
	if (device) return device;
	device = Device_0xB350::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0601::createDevice(deviceId);
	if (device) return device;
	device = Device_0x1106::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0814::createDevice(deviceId);
	if (device) return device;
	device = Device_0x1007::createDevice(deviceId);
	if (device) return device;
	device = Device_0x1005::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0909::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0723::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0541::createDevice(deviceId);
	if (device) return device;
	device = Device_0xC330::createDevice(deviceId);
	if (device) return device;
	device = Device_0xC803::createDevice(deviceId);
	if (device) return device;
	device = Device_0xC911::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD121::createDevice(deviceId);
	if (device) return device;
	device = Device_0xD352::createDevice(deviceId);
	if (device) return device;
	device = Device_0x0507::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8850::createDevice(deviceId);
	if (device) return device;
	return nullptr;
}
SuperIODevice *createDeviceITE(uint16_t deviceId) {
	SuperIODevice *device;
	device = Device_0x8705::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8712::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8721::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8726::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8620::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8628::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8686::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8728::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8752::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8771::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8772::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8792::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8688::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8795::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8665::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8613::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8987::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8716::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8718::createDevice(deviceId);
	if (device) return device;
	device = Device_0x8720::createDevice(deviceId);
	if (device) return device;
	return nullptr;
}
SuperIODevice *createDeviceEC(const char *name) {
	SuperIODevice *device;
	device = Device_Intel_EC_V9::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_VB::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V8::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_VA::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V2::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V4::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V6::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V1::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V3::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V7::createDevice(name);
	if (device) return device;
	device = Device_Intel_EC_V5::createDevice(name);
	if (device) return device;
	return nullptr;
}
