<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>SMC Keys</title>
</head>
<body>
<center><h1>SMC Keys</h1></center>
<center><h2>K3 Version: 1.30f1</h2></center>
<p>
<table cellpadding="2" cellspacing="2" border="1" width="100%"> 
<tr>
<th align="center">KEY</th>
<th align="center">TYPE</th>
<th align="center">SIZE</th>
<th align="center">ATTRIBUTES</th>
<th align="left">DESCRIPTION</th>
</tr>
<tr>
<td align="center"><code>#KEY</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Number of Keys</code>
</tr>
<tr>
<td align="center"><code>+LKS</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><pre>Returns whether or not lock bits are set.  Returns 3 bit value, where<br> each bit represents one of the three lock bit regions.  1 =&gt; set. <br></pre>
</tr>
<tr>
<td align="center"><code>AL!</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><pre>Each "1" bit in gui8ALSForced indicates that a certain writable ALS<br> variable has been overridden (i.e., forced) by the host OS or <br> host diagnostics, and that variable should not be written by the SMC <br> again until the applicable bit is cleared in gui8ALSForced.<br> Currently, the used bits are:<br>    Bit 0 protects gui16ALSScale<br>    Bit 1 protects ui16Chan0 and ui16Chan1 of aalsvALSData<br>    Bit 2 protects gui16ALSLux<br>    Bit 3 protects fHighGain of aalsvALSData<br>    Bit 4 protects gai16ALSTemp[MAX_ALS_SENSORS]<br> All other bits are reserved and should be cleared to 0. <br></pre>
</tr>
<tr>
<td align="center"><code>ALA0</code>
<td align="center"><code>{ala</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS analog lux calculation information</code>
</tr>
<tr>
<td align="center"><code>ALA1</code>
<td align="center"><code>{ala</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS analog lux calculation information</code>
</tr>
<tr>
<td align="center"><code>ALA2</code>
<td align="center"><code>{ala</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS analog lux calculation information</code>
</tr>
<tr>
<td align="center"><code>ALA3</code>
<td align="center"><code>{ala</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS analog lux calculation information</code>
</tr>
<tr>
<td align="center"><code>ALA4</code>
<td align="center"><code>{ala</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS analog lux calculation information</code>
</tr>
<tr>
<td align="center"><code>ALA5</code>
<td align="center"><code>{ala</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS analog lux calculation information</code>
</tr>
<tr>
<td align="center"><code>ALAT</code>
<td align="center"><code>{alt</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>analog lux calculation thresholds</code>
</tr>
<tr>
<td align="center"><code>ALI0</code>
<td align="center"><code>{ali</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>ALS Sensor 0 Info</code>
</tr>
<tr>
<td align="center"><code>ALI1</code>
<td align="center"><code>{ali</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>ALS Sensor 1 Info</code>
</tr>
<tr>
<td align="center"><code>ALRV</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>ALS/SIL version ID for the application program interface</code>
</tr>
<tr>
<td align="center"><code>ALSC</code>
<td align="center"><code>{alc</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>ALS Configuration (some fields of which are used by the SIL<br> on both ALS and non-ALS systems) <br></pre>
</tr>
<tr>
<td align="center"><code>ALSF</code>
<td align="center"><code>fp1f</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS Scale Factor for SIL in 1.15 fixed-point representation</code>
</tr>
<tr>
<td align="center"><code>ALSL</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Average ALS Ambient Light Reading in Lux</code>
</tr>
<tr>
<td align="center"><code>ALT0</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS Ambient Light Sensor Temperature for sensor 0 (deg C, FP16.0)</code>
</tr>
<tr>
<td align="center"><code>ALT1</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS Ambient Light Sensor Temperature for sensor 1 (deg C, FP16.0)</code>
</tr>
<tr>
<td align="center"><code>ALTH</code>
<td align="center"><code>{alr</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ALS Ambient Light Sensor Thermal Coefficient and baseline temperature</code>
</tr>
<tr>
<td align="center"><code>ALV0</code>
<td align="center"><code>{alv</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Latest ambient light reading from sensor 0</code>
</tr>
<tr>
<td align="center"><code>ALV1</code>
<td align="center"><code>{alv</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Latest ambient light reading from sensor 1</code>
</tr>
<tr>
<td align="center"><code>AUPO</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Auto Power-on key.  If set to 1, system will be automatically <br> powered on by SMC after next transition to S5/G3HOT. <br></pre>
</tr>
<tr>
<td align="center"><code>BATP</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>System currently being powered by battery. Used by FW TDM. Needed on all platforms.</code>
</tr>
<tr>
<td align="center"><code>BNum</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>Maximum number of supported batteries. Architecturally visiable key used by EFIUtil. Needed on all platforms.</code>
</tr>
<tr>
<td align="center"><code>BSIn</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><pre>Battery System info byte. BSIn[7:0]<br> 0=Charging<br> 1=AC present<br> 2=AC presence changed<br> 3=OS Stop Charge<br> 4=OS Calibration Req<br> 5=BatteryQueryInProgress<br> 6=batOK<br> 7=adcInProgress<br> Architecturally visiable key used by EFIUtil. Needed on all platforms.  <br></pre>
</tr>
<tr>
<td align="center"><code>CLKT</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><pre>SMC local time in seconds since midnight<br> Used to control SIL brightness on some systems based on time of day. <br></pre>
</tr>
<tr>
<td align="center"><code>CRCB</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>Returns a CRC32 value representing all of UserBootMAT.</code>
</tr>
<tr>
<td align="center"><code>CRCU</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>Generates a CRC32 value representing all of UserMAT.</code>
</tr>
<tr>
<td align="center"><code>DPLM</code>
<td align="center"><code>{lim</code>
<td align="center"><code></code>
<td align="left"><code>KPRIV_FUNC_W</code>
<td align="left"><code>Tests Plimit plumbing from SMC to OS.  3 bytes input are Cpu Plimit, Gpu Plimit, Mem Plimit.</code>
</tr>
<tr>
<td align="center"><code>EPCA</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>EPM CV Start Address</code>
</tr>
<tr>
<td align="center"><code>EPCF</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>EPM CV Flash Status  1=flashed</code>
</tr>
<tr>
<td align="center"><code>EPCI</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>EPM CV Configuration ID</code>
</tr>
<tr>
<td align="center"><code>EPCV</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>EPM CV Configuration Version</code>
</tr>
<tr>
<td align="center"><code>EPMA</code>
<td align="center"><code>ch8*</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>EPM Meta Table Address  First set EPMI and then read EPMA</code>
</tr>
<tr>
<td align="center"><code>EPMI</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>EPM Meta Table Index  First set EPMI and then read EPMA</code>
</tr>
<tr>
<td align="center"><code>EPUA</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>EPM UV Start Address</code>
</tr>
<tr>
<td align="center"><code>EPUF</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>EPM UV Flash Status. 1=flashed</code>
</tr>
<tr>
<td align="center"><code>EPUI</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>EPM UV Configuration ID</code>
</tr>
<tr>
<td align="center"><code>EPUV</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>EPM UV Configuration Version</code>
</tr>
<tr>
<td align="center"><code>EVCT</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><pre>Event Trace Buffer. Returns a 2 byte value. The first byte is the number of events<br> that have been put into the trace buffer since the last time this key was read and the second<br> is the index into the buffer for the next event to be written. <br> If they are not the same, then the trace buffer has been overwritten and more then 16 events <br> have occured since the last time it was read  <br></pre>
</tr>
<tr>
<td align="center"><code>EVMD</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>Event Mode. Used for debug to determine if we should reset SMC or jump into flasher on<br> a detected SMC health check. If key is written to a value of 0x87126534, then we will jump into the <br> flasher on any SMC health check. <br></pre>
</tr>
<tr>
<td align="center"><code>EVRD</code>
<td align="center"><code>ch8*</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><pre>Event Trace Buffer Read. 32 byte read from event trace buffer. Issue key read 4 times to<br> read entire event trace buffer  <br></pre>
</tr>
<tr>
<td align="center"><code>F0Ac</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan0 Actual RPM, DIAG_LOG</code>
</tr>
<tr>
<td align="center"><code>F0ID</code>
<td align="center"><code>{fds</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Fan0 Description</code>
</tr>
<tr>
<td align="center"><code>F0Mn</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan0 Minimum RPM</code>
</tr>
<tr>
<td align="center"><code>F0Mt</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan0 Max calculated target RPM</code>
</tr>
<tr>
<td align="center"><code>F0Mx</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan0 Maximum RPM</code>
</tr>
<tr>
<td align="center"><code>F0Sf</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan0 Safe RPM</code>
</tr>
<tr>
<td align="center"><code>F0Tg</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Modify this in conjunction with Fan force bit [0] to set fan speed.  <br></pre>
</tr>
<tr>
<td align="center"><code>F1Ac</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan1 Actual RPM</code>
</tr>
<tr>
<td align="center"><code>F1ID</code>
<td align="center"><code>{fds</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Fan1 Description</code>
</tr>
<tr>
<td align="center"><code>F1Mn</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan1 Minimum RPM</code>
</tr>
<tr>
<td align="center"><code>F1Mt</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan1 Max calculated target RPM</code>
</tr>
<tr>
<td align="center"><code>F1Mx</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan1 Maximum RPM</code>
</tr>
<tr>
<td align="center"><code>F1Sf</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan1 Safe RPM</code>
</tr>
<tr>
<td align="center"><code>F1Tg</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Modify this in conjunction with Fan force bit [1] to set fan speed.  <br></pre>
</tr>
<tr>
<td align="center"><code>F2Ac</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan2 Actual RPM</code>
</tr>
<tr>
<td align="center"><code>F2ID</code>
<td align="center"><code>{fds</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Fan2 Description</code>
</tr>
<tr>
<td align="center"><code>F2Mn</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan2 Minimum RPM</code>
</tr>
<tr>
<td align="center"><code>F2Mt</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan2 Max calculated target RPM</code>
</tr>
<tr>
<td align="center"><code>F2Mx</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan2 Maximum RPM</code>
</tr>
<tr>
<td align="center"><code>F2Sf</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Fan2 Safe RPM</code>
</tr>
<tr>
<td align="center"><code>F2Tg</code>
<td align="center"><code>fpe2</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Modify this in conjunction with Fan force bit [2] to set fan speed.  <br></pre>
</tr>
<tr>
<td align="center"><code>FNum</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Number of supported fans.</code>
</tr>
<tr>
<td align="center"><code>FPhz</code>
<td align="center"><code>si16</code>
<td align="center"><code>2</code>
<td align="left"><code>KPRIV_VAR_ATOM_RW</code>
<td align="left"><pre>Programmable Fan Phase offset affects all fans.  Signed value<br>  has legal values between 0 and 360.  Default is 360 (no change). <br></pre>
</tr>
<tr>
<td align="center"><code>FS!</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Fan force bits. FS![15:0] Setting bit to 1 allows for external control over fan speed target and<br> prevents thermal manager from actively overidding value set via key access. <br></pre>
</tr>
<tr>
<td align="center"><code>GCID</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Graphics Card Identification.  Communicates the graphics<br> card's Device ID (DID) and Vendor ID (VID) to the SMC so that the SMC<br> can communicate with that graphics card's thermal sensor(s).  The 32-bit<br> value that is written to this key contains the graphics card's DID in<br> its most-significant 16 bits, and the VID occupies the least-significant<br> 16-bits. <br></pre>
</tr>
<tr>
<td align="center"><code>GPU!</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>MXM GPU Force bits[7:0]: GPU![0] = GTHR force override<br> bit. <br></pre>
</tr>
<tr>
<td align="center"><code>GTHR</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>MXM_GPU_AC_BATT_L. Drive SMC output with written value.<br> Needs to be written in conjunction with GPU![0].  <br></pre>
</tr>
<tr>
<td align="center"><code>HBWK</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><code>Allows a one-time lid-open event to "wake" the system from S5.</code>
</tr>
<tr>
<td align="center"><code>HDBS</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Hang Detect. A/B switch value</code>
</tr>
<tr>
<td align="center"><code>HDST</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Hang Detect. Current System State Machine value</code>
</tr>
<tr>
<td align="center"><code>HDSW</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Hang Detect. {Sleep[15:0]|Wake[15:0]} Count.</code>
</tr>
<tr>
<td align="center"><code>IC0C</code>
<td align="center"><code>fp79</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 core current.</code>
</tr>
<tr>
<td align="center"><code>ID0R</code>
<td align="center"><code>fp5b</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC In S0 rail current.</code>
</tr>
<tr>
<td align="center"><code>ID5R</code>
<td align="center"><code>fp4c</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC In S5 rail current.</code>
</tr>
<tr>
<td align="center"><code>IG0R</code>
<td align="center"><code>fp4c</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 rail current.</code>
</tr>
<tr>
<td align="center"><code>IG0r</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 rail current. Raw ADC input value.</code>
</tr>
<tr>
<td align="center"><code>LAcN</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>KPRIV_FUNC_W</code>
<td align="left"><code>Queue up ACPI Notify byte</code>
</tr>
<tr>
<td align="center"><code>LAtN</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>KPRIV_FUNC_W</code>
<td align="left"><code>Queue up Proprietary ATTN_IF Notify byte</code>
</tr>
<tr>
<td align="center"><code>LCCN</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>LPC Debug counter data: Num of Acpi Notifies</code>
</tr>
<tr>
<td align="center"><code>LCCQ</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>LPC Debug counter data: Num of Acpi Queries</code>
</tr>
<tr>
<td align="center"><code>LCKA</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>LPC Debug counter data: Num of Key Accesses</code>
</tr>
<tr>
<td align="center"><code>LCSA</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>LPC Debug counter data: Num of Smb Accesses</code>
</tr>
<tr>
<td align="center"><code>LCTN</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>LPC Debug counter data: Num of Attn Notifies</code>
</tr>
<tr>
<td align="center"><code>LCTQ</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>LPC Debug counter data: Num of Attn Queries</code>
</tr>
<tr>
<td align="center"><code>LDSP</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_W</code>
<td align="left"><code>When OS X sleeps due to a lid-closed event, it writes a 1 in this key.</code>
</tr>
<tr>
<td align="center"><code>LS!</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><pre>Each "1" bit in gui8LmsForced indicates that a certain writable SIL<br> variable has been overridden (i.e., forced) by the host OS or <br> host diagnostics, and that variable should not be written by the SMC <br> again until the applicable bit is cleared in gui8LmsForced.<br> Currently, this is just a place-holder.  All bits are reserved and <br> should be cleared to 0. <br></pre>
</tr>
<tr>
<td align="center"><code>LSCF</code>
<td align="center"><code>{lsc</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LmsConfig structure provides overall system-specific config info for the SIL.</code>
</tr>
<tr>
<td align="center"><code>LSDD</code>
<td align="center"><code>{lsd</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LmsDwell structures provide dwell fade-down configuration</code>
</tr>
<tr>
<td align="center"><code>LSDU</code>
<td align="center"><code>{lsd</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LmsDwell structures provide dwell fade-up configuration</code>
</tr>
<tr>
<td align="center"><code>LSFD</code>
<td align="center"><code>{lsf</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LmsFlare structures provide flare config for non-breathing fade-down</code>
</tr>
<tr>
<td align="center"><code>LSFU</code>
<td align="center"><code>{lsf</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LmsFlare structures provide flare config for non-breathing fade-up</code>
</tr>
<tr>
<td align="center"><code>LSLB</code>
<td align="center"><code>{pwm</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>SIL's PWM "Full On" value (usually 0xFFFF, used for power switch override)</code>
</tr>
<tr>
<td align="center"><code>LSLF</code>
<td align="center"><code>{pwm</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>SIL's PWM "Off" value (usually 0)</code>
</tr>
<tr>
<td align="center"><code>LSLN</code>
<td align="center"><code>{pwm</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>SIL's PWM "On" value (varies per system)</code>
</tr>
<tr>
<td align="center"><code>LSOF</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>Reads TRUE (1) if the SIL is Off</code>
</tr>
<tr>
<td align="center"><code>LSOO</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8LmsSetOnOff is a function called by the OS to set<br> the SIL to either on (max brightness, flag=1) or off (flag = 0). <br></pre>
</tr>
<tr>
<td align="center"><code>LSPV</code>
<td align="center"><code>{pwm</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>SIL's Current PWM value</code>
</tr>
<tr>
<td align="center"><code>LSRB</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8LmsRevertToSSMBehavior is a function called by the OS to revert the<br> SIL's behavior to the most recent behavior requested by the SMC's system<br> state machine. <br></pre>
</tr>
<tr>
<td align="center"><code>LSSB</code>
<td align="center"><code>{lso</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8LmsSetBehavior is a function called by the OS to override the SIL's<br> behavior.  The calling parameters must conform to the<br> LmsOverrideBehavior struct. <br></pre>
</tr>
<tr>
<td align="center"><code>LSSE</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><pre>gfLmsMaxBrightScalingEnabled lets diagnotics enable and<br> disable the SIL's per-unit max brightness scaling.  This flag will<br> normally be 1 (i.e, TRUE), which enables per-unit scaling.  Set this<br> flag to 0 (FALSE) to disable per-unit scaling.  <br></pre>
</tr>
<tr>
<td align="center"><code>LSSS</code>
<td align="center"><code>{lso</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8LmsSetSSMBehavior is a function called by the OS to<br> override the SIL's behavior while pretending to be the SMC's System<br> State Machine (host software should normally use LSSB instead of this<br> special-purpose key).  The calling parameters must conform to the<br> LmsOverrideBehavior struct. <br></pre>
</tr>
<tr>
<td align="center"><code>LSSV</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><pre>gui16LmsMaxBrightScale holds the SIL's per-unit max <br> brightness scale value.  A value of 0xFFFF indicates that no scaling<br> will be done for this particular unit.  <br></pre>
</tr>
<tr>
<td align="center"><code>LSUP</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8LmsUpdateBehaviorParams is a function called by the SIL tuning<br> application to force an update of the SIL's behavior parameters at the<br> user's implicit request (i.e., after the user updates underlying data<br> that affects the behavior params). <br></pre>
</tr>
<tr>
<td align="center"><code>MACA</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Memory Address Cycle Address. Sets the address for subsequent MACR calls</code>
</tr>
<tr>
<td align="center"><code>MACM</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Memory Address Cycle Mode. Sets the addressing mode for MACR calls. Defaults to auto-incrementing</code>
</tr>
<tr>
<td align="center"><code>MACR</code>
<td align="center"><code>ch8*</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><pre>Memory Address Cycle Read. Reads 32 bytes from SMC @ address pointed to by MACA. Restricted to EPM address range. If<br> MACM==1 then MACA will be incremented by 32 bytes at the completion of the read. <br></pre>
</tr>
<tr>
<td align="center"><code>MOCF</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>MOtion sensor (SMS) Configuration register</code>
</tr>
<tr>
<td align="center"><code>MOCN</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>MOtion sensor (SMS) Control register - enables accelerometer and threshold testing</code>
</tr>
<tr>
<td align="center"><code>MSAL</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>KWPRIV_FUNC_RW</code>
<td align="left"><pre>Allows control of the thermal routine's behavior for debug and testing purposes.<br>7 - Unused<br>6 - Plimits enabled.  0 =&gt; thermal routine will not send plimits, but<br>    all other thermal code is still active.  1 =&gt; routine sends plimits<br>    normally, assuming routine is active.<br>5 - Unused  <br>4 - Unused  <br>3 - Thermal Subsystem Operating Normally, read-only.  If this bit is 1,<br>    the SMC's thermal subsystem is operating normally.  If it is 0, then<br>    the thermal code is disabled, fans are set to max RPM, and plimits<br>    are all set to max.  On systems that require a throttle selector<br>    table in the UV EPM block, this bit will be set to 0 if the throttle<br>    selector table is invalid or is missing.<br>2 - Valid current/power calibration coefficients in UV EPM block,<br>    read-only.<br>1 - Prochot Enable<br>0 - Thermtrip Enable <br></pre>
</tr>
<tr>
<td align="center"><code>MSAc</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Returns the average CPU PLIMIT sent by the SMC, DIAG_LOG</code>
</tr>
<tr>
<td align="center"><code>MSAg</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Returns the average GPU PLIMIT sent by the SMC, DIAG_LOG</code>
</tr>
<tr>
<td align="center"><code>MSAm</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Returns the average MEM PLIMIT sent by the SMC, DIAG_LOG</code>
</tr>
<tr>
<td align="center"><code>MSC0</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSC1</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSC2</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSC3</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCP</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Total number of sub samples to calibrate with</code>
</tr>
<tr>
<td align="center"><code>MSCR</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Total number of sub samples to calibrate with</code>
</tr>
<tr>
<td align="center"><code>MSCS</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><code>Calibration Start key - Writing a value of 0x11 to this key will begin</code>
</tr>
<tr>
<td align="center"><code>MSCT</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Total number of samples to calibrate with</code>
</tr>
<tr>
<td align="center"><code>MSCa</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCb</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCc</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCd</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCl</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCm</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCn</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSCo</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Calibration key</code>
</tr>
<tr>
<td align="center"><code>MSDI</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><pre>Indicates whether an optical disk has been inserted in the<br> optical disk drive (1) or the drive is empty (0).  <br></pre>
</tr>
<tr>
<td align="center"><code>MSDW</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8SSMDisplayWakeSleep is a function called by the OS to notify the SMC<br> that the display is now awake (i.e., on) or asleep (i.e. off), so that<br> the SMC can set the correct behavior for the Status Indicator Light.  <br></pre>
</tr>
<tr>
<td align="center"><code>MSHA</code>
<td align="center"><code>fp79</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Average HDD activity (range 0 to 1) in U7.9 format.</code>
</tr>
<tr>
<td align="center"><code>MSLD</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>Returns the current Lid Switch state</code>
</tr>
<tr>
<td align="center"><code>MSPA</code>
<td align="center"><code>fp6a</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Average count of prochot assertions between 0 and 1 in 6.10 format, DIAG_LOG.</code>
</tr>
<tr>
<td align="center"><code>MSPC</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><code>reads and writes the number of available "Power states" for the CPU.</code>
</tr>
<tr>
<td align="center"><code>MSPS</code>
<td align="center"><code>{msp</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><pre>Returns the current (enumerated) system power state exported by the <br> SMC's System State Machine.  <br></pre>
</tr>
<tr>
<td align="center"><code>MSSD</code>
<td align="center"><code>si8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><pre>Stores the last known Shut-down cause.<br> STOP_CAUSE_SHUTDOWN_GOOD_CODE        5<br> STOP_CAUSE_SLEEP_GOOD_CODE           5<br> STOP_CAUSE_POWERKEY_GOOD_CODE        3<br> SLEEP_CAUSE_SLEEP_LOWBATT_CODE       2     // Deprecated. Use STOP_CAUSE_LOWBATT<br> SLEEP_CAUSE_SLEEP_OVERTEMP_CODE      1     // Deprecated. Use appropriate STOP_CAUSE_TEMP*<br> STOP_CAUSE_INIT_CODE                 0     // Initial code<br> STOP_CAUSE_HEALTHCHECK_CODE          -1    // 0xFF<br> STOP_CAUSE_PS_CODE                   -2    // 0xFE<br> STOP_CAUSE_TEMP_MULTISLEEP_CODE      -3    // 0xFD<br> STOP_CAUSE_SENSORFAN_CODE            -4    // 0xFC<br> STOP_CAUSE_TEMP_OVERLIMITTO_CODE     -30   // 0xE2<br> STOP_CAUSE_PSWRSMRST_CODE            -40   // 0xD8<br> STOP_CAUSE_UNMAPPED_CODE             -50   // 0xCE Deprecated because it should never occur<br> STOP_CAUSE_LOWBATT_CODE              -60   // 0xC4<br> STOP_CAUSE_NINJA_SHUTDOWN_CODE       -61   // 0xFF<br> STOP_CAUSE_NINJA_RESTART_CODE        -62   // 0xC2<br> STOP_CAUSE_TEMP_PALM_CODE            -70   // 0xBA<br> STOP_CAUSE_TEMP_SODIMM_CODE          -71   // 0xB9<br> STOP_CAUSE_TEMP_HEATPIPE_CODE        -72   // 0xB8<br> STOP_CAUSE_TEMP_BATT_CODE            -74   // 0xB6<br> STOP_CAUSE_ADAPTERTO_CODE            -75   // 0xB5<br> STOP_CAUSE_TEMP_MANUAL_CODE          -77   // 0xB3 Not currently used.<br> STOP_CAUSE_CURRENT_ADAPTER_CODE      -78   // 0xB2<br> STOP_CAUSE_CURRENT_BATT_CODE         -79   // 0xB1<br> STOP_CAUSE_TEMP_SKIN_CODE            -82   // 0xAE<br> STOP_CAUSE_TEMP_BACKUP_CODE          -84   // 0xAC<br> STOP_CAUSE_TEMP_SKIN_BOTHBAD_CODE    -83   // 0xAB Will die with M57, M59, M75, M76<br> STOP_CAUSE_TEMP_CPUPROX_CODE         -86   // 0xAA<br> STOP_CAUSE_TEMP_CPU_CODE             -95   // 0xA1<br> STOP_CAUSE_TEMP_PS_CODE              -100  // 0x9C<br> STOP_CAUSE_TEMP_LCD_CODE             -101  // 0x9B<br> STOP_CAUSE_RSM_POWER_FAIL_CODE       -102  // 0x9A<br> STOP_CAUSE_BATT_CUV_CODE             -103  // 0x99<br> STOP_CAUSE_UNKNOWN_CODE              -128  // 0x80 for unknown shutdown cause<br>  <br></pre>
</tr>
<tr>
<td align="center"><code>MSSF</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><pre>Bad fan flag bits. A bit-vector in which each bit position represents a corresponding fan status. The <br> bit-vector is write-one-to-clear for each fan/bit position <br></pre>
</tr>
<tr>
<td align="center"><code>MSSP</code>
<td align="center"><code>si8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><code>Stores the last known Sleep Request cause.  See MSSD for list of causes.</code>
</tr>
<tr>
<td align="center"><code>MSSS</code>
<td align="center"><code>{mss</code>
<td align="center"><code></code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>Returns the current (enumerated) state of the SMC's System State Machine</code>
</tr>
<tr>
<td align="center"><code>MSTC</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>- ScratchPad register that outputs via Tlog so that a script running on the SUT can add to the log what test case was running.</code>
</tr>
<tr>
<td align="center"><code>MSTM</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>Returns whether power balancing is enabled or not.</code>
</tr>
<tr>
<td align="center"><code>MSTc</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Returns the last CPU PLIMIT sent by the SMC</code>
</tr>
<tr>
<td align="center"><code>MSTg</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Returns the last GPU PLIMIT sent by the SMC</code>
</tr>
<tr>
<td align="center"><code>MSTm</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Returns the last MEM PLIMIT sent by the SMC</code>
</tr>
<tr>
<td align="center"><code>MSWR</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>ui8SSMStartWarmReset is a function called by the OS to notify that SMC <br> that a warm reset is beginning. <br></pre>
</tr>
<tr>
<td align="center"><code>NATJ</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_RW</code>
<td align="left"><pre>Ninja Action Timer Job.  This job is performed when the Ninja Action Timer<br> counts down to zero.  Job can be any of:<br> 0 = Do Nothing<br> 1 = Force Shutdown to S5<br> 2 = Force Restart<br> 3 = Force Startup<br> 4 = reserved <br></pre>
</tr>
<tr>
<td align="center"><code>NATi</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>Ninja Action Timer.  This timer can be set to the number of seconds before a job<br> (defined in NATJ) is performed.  Value is in seconds and counts down to zero.  Setting to zero<br> cancels any previously set timer. <br></pre>
</tr>
<tr>
<td align="center"><code>NTOK</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><code>Key for OS X to write to turn on Proprietary Host Notifies.</code>
</tr>
<tr>
<td align="center"><code>ONMI</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>NMI flag (For OS NMI)</code>
</tr>
<tr>
<td align="center"><code>PC0C</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 core power</code>
</tr>
<tr>
<td align="center"><code>PC0c</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 core power. Raw ADC input value.</code>
</tr>
<tr>
<td align="center"><code>PD0R</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC-In MLB S0 rail power</code>
</tr>
<tr>
<td align="center"><code>PD5R</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC-In MLB S5 rail power</code>
</tr>
<tr>
<td align="center"><code>PDMR</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC-In MLB Total (S0+S5) power</code>
</tr>
<tr>
<td align="center"><code>PDTR</code>
<td align="center"><code>fpa6</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC-In System Total (S0+S5+LCD+HDD) power</code>
</tr>
<tr>
<td align="center"><code>PG0R</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU0 rail power</code>
</tr>
<tr>
<td align="center"><code>PZ0E</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Zone0 average target power (PC0C+PG0R)</code>
</tr>
<tr>
<td align="center"><code>PZ0G</code>
<td align="center"><code>fp88</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Zone0 average power (PC0C+PG0R)</code>
</tr>
<tr>
<td align="center"><code>RBr</code>
<td align="center"><code>ch8*</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><code>Source branch</code>
</tr>
<tr>
<td align="center"><code>REV</code>
<td align="center"><code>{rev</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Source revision</code>
</tr>
<tr>
<td align="center"><code>RMde</code>
<td align="center"><code>char</code>
<td align="center"><code>1</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Mode. What code is currently being executed. 'B'=base flasher, 'U'=update flasher or 'A'=app code</code>
</tr>
<tr>
<td align="center"><code>RPlt</code>
<td align="center"><code>ch8*</code>
<td align="center"><code></code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Platform String</code>
</tr>
<tr>
<td align="center"><code>RSvn</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>SVN database revision</code>
</tr>
<tr>
<td align="center"><code>RVBF</code>
<td align="center"><code>{rev</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>Base flasher revision</code>
</tr>
<tr>
<td align="center"><code>RVUF</code>
<td align="center"><code>{rev</code>
<td align="center"><code></code>
<td align="left"><code>K_FUNC_R</code>
<td align="left"><code>Update flasher revision</code>
</tr>
<tr>
<td align="center"><code>SAS!</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>KWPRIV_VAR_ATOM_RW</code>
<td align="left"><pre>ADC sensor force bits [31:0]. Setting bit(s) will prevent periodic ADC conversion cycle from overwriting<br> sensor data for selected channels. <br></pre>
</tr>
<tr>
<td align="center"><code>SBF</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><pre>Bad sensor flags.  One per PID, defined as follows:<br> PID  Bit   Hex     Dec<br> ---  ---  ------   ---<br> CPU   0   0x0001     1<br> GPU   1   0x0002     2<br> HDD   2   0x0004     4<br> ODD   3   0x0008     8<br> PS    4   0x0010    16<br> LCD   5   0x0020    32 <br></pre>
</tr>
<tr>
<td align="center"><code>SBFC</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>When a bit has been set by the SMC in SBF key and is then subsequently reset by writing<br> this key, it will cause the appropriate data elements for the PID to be reset <br> and the pid will resume normal behaviour if it's sensors are working properly again. <br> Note that it may take a few minutes for the fans associated with that PID loop to return <br> to normal speed due to PID loop tuning. <br></pre>
</tr>
<tr>
<td align="center"><code>SBFE</code>
<td align="center"><code>flag</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>The state of this flag determines whether vTmBadSensorCheck<br> will display sensor error codes instead of actual temperatures when it<br> detects unstable temperatures or temperatures that are below the allowed<br> minimum.  Defaults to TRUE (displays error codes).<br></pre>
</tr>
<tr>
<td align="center"><code>SCIA</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><code>Lpc Base Address for SCIF, default is 0x3F8</code>
</tr>
<tr>
<td align="center"><code>SCIL</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><code>Set this to 1 to enable SCIF to be LPC slave for EFI debug</code>
</tr>
<tr>
<td align="center"><code>SCTg</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU Thermal Target Temp</code>
</tr>
<tr>
<td align="center"><code>SDPE</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Mode bit to enable polling of developmental build sensors. Default state will vary depending on build.</code>
</tr>
<tr>
<td align="center"><code>SDRd</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>Delayed sensor read. Writing a value in ms will cause the SMC to start a timer which when<br> expires will cause the SMC to set force bits for polled sensors. This effectively allows a follow on<br> query to sample the state of the sensors at the desired time. Value in ms. <br></pre>
</tr>
<tr>
<td align="center"><code>SGHT</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Sensor Graphics HoT.  1 = GPU Overtemp.</code>
</tr>
<tr>
<td align="center"><code>SGTT</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><pre>GPU Heatsink Throttle Threshold Temperature.  If the GPU's<br> heatsink temperature exceeds this temperature, the SMC will assert the<br> GPU's throttle to slow and cool the GPU.  <br></pre>
</tr>
<tr>
<td align="center"><code>SGTg</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU Thermal Target Temp</code>
</tr>
<tr>
<td align="center"><code>SHTg</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>HDD Thermal Target Temp</code>
</tr>
<tr>
<td align="center"><code>SIS!</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>KWPRIV_VAR_ATOM_RW</code>
<td align="left"><pre>I2C sensor force bits. Setting bit(s) will prevent periodic<br> I2C polling cycle overwriting sensor data. This key is intended for<br> expert use only.  Bit mappings for M72/M78/K2/K3 are as follows:<br> <br> Bit   Hex      Dec    Key   Description<br> ---  ------   -----   ----  ------------<br>  0   0x0001       1   TC0H  CPU Heatsink<br>  1   0x0002       2   TG0H  GPU Heatsink<br>  2   0x0004       4   TH0P  HDD Proximity<br>  3   0x0008       8   TO0P  ODD Proximity<br>  4   0x0010      16   Tm0P  MLB Proximity<br>  5   0x0020      32   TA0P  Ambient<br>  6   0x0040      64   Tp0P  Power Supply Proximity<br>  7   0x0080     128   TW0P  Wireless (Airport) Proximity<br>  8   0x0100     256   TC0P  CPU Proximity<br>  9   0x0200     512   TC0D  CPU Die<br> 10   0x0400    1024   TG0P  GPU Proximity<br> 11   0x0800    2048   TG0D  GPU Die<br> 12   0x1000    4096   TL0P  LCD Proximity<br> 13   0x2000    8192   SGTT  GPU Heatsink Throttle Threshold<br> <br> Special error codes (used by individual temperature keys, not by SIS!):<br>  Hex     Dec    Description<br> ------  -----   -----------<br> 0x7FE7   127.9  Hot temperature<br> 0x8400  -124    Unstable temperature<br> 0x8300  -125    Temperature below allowed minimum<br> 0x8200  -126    Sensor failed to initialize<br> 0x8100  -127    Sensor skipped<br> 0x8000  -128    Temperature can't be read <br></pre>
</tr>
<tr>
<td align="center"><code>SLPT</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LCD Prochot threshold. TL0P temp at which Prochot will be asserted.</code>
</tr>
<tr>
<td align="center"><code>SLST</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LCD Sleep threshold. TL0P temp at which Sleep will be requested.</code>
</tr>
<tr>
<td align="center"><code>SLTg</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LCD Fan Temp Target</code>
</tr>
<tr>
<td align="center"><code>SLTp</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LCD Power Temp Target</code>
</tr>
<tr>
<td align="center"><code>SOTg</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>ODD Thermal Target Temp</code>
</tr>
<tr>
<td align="center"><code>SPH0</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_R</code>
<td align="left"><code>CPU Prochot event count since last boot</code>
</tr>
<tr>
<td align="center"><code>SPHR</code>
<td align="center"><code>ui32</code>
<td align="center"><code>4</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><pre>Any bit set to 1 identifies an active Prochot requestor.<br> For K2/K3, the following bits are defined:<br> Bit 31:  User-forced Prochot<br> Bit 30:  RSVD for "Prochot forever in lieu of Thermtrip" (currently unused)<br> Bits 4-29:  RSVD<br> Bit  3:  Prochot Power Index<br> Bit  2:  Power-supply overcurrent<br> Bit  1:  Power-supply overtemp<br> Bit  0:  LCD panel overtemp <br></pre>
</tr>
<tr>
<td align="center"><code>SPHS</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Indicates if PROCHOT was ever set after entering S0, DIAG_LOG</code>
</tr>
<tr>
<td align="center"><code>SPHT</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><pre>Current state of all Prochots and whether the SMC itself is<br> asserting each one.<br> Bits 0-7:   Prochot state for CPUs 0-7, respectively (1 bit per CPU).<br>             1 = Prochot asserted.  0 = Prochot deasserted.<br> Bits 8-15:  The SMC itself is asserting Prochot for CPUs 0-7,<br>             respectively (1 bit per CPU; bit 8 corresponds to CPU 0,<br>             bit 15 corresponds to CPU 7).<br>             1 = SMC is asserting Prochot to that CPU.<br>             0 = SMC is NOT asserting Prochot to that CPU.<br> <br></pre>
</tr>
<tr>
<td align="center"><code>SPHZ</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_W</code>
<td align="left"><pre>Drive SMC Prochot(s).  In the single byte of write data,<br> bits 0 through 7 control the Prochots for CPUs 0 through 7,<br> respectively.  For example, writing 0x01 sets Prochot for CPU 0, while<br> writing 0x80 sets Prochot for CPU 7, and writing 0xFF sets all 8<br> Prochots.  Setting bits for CPUs that don't exist does nothing<br> and causes no harm.<br> <br></pre>
</tr>
<tr>
<td align="center"><code>SPS!</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>KWPRIV_VAR_ATOM_RW</code>
<td align="left"><pre>Power force bits. Setting bit(s) will prevent periodic power calculations from overwriting<br> existing data. Bit mapping varies by platform and is intended for expert use only. <br></pre>
</tr>
<tr>
<td align="center"><code>SpCP</code>
<td align="center"><code>fps4</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><pre>Read-only PS I-squared sum Prochot threshold in U27.4 format.<br> Sample computation:  [(Prochot threshold in watts)/12v]^2 * (Filter depth = 24576)<br>                      Hex value is the above * 16. <br></pre>
</tr>
<tr>
<td align="center"><code>SpCS</code>
<td align="center"><code>fps4</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><pre>Read-only PS I-squared sum target for P3-level PS current control, in U27.4 format.<br> Sample computation:  [(Target in watts)/12v]^2 * (Filter depth = 24576)<br>                      Hex value is the above * 16. <br></pre>
</tr>
<tr>
<td align="center"><code>SpCT</code>
<td align="center"><code>fpc4</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><pre>Read-only PS I-squared target (non-summed) for initializing PS current control filter history, in U12.4 format.<br> Sample computation:  [(Target in watts)/12v]^2.<br>                      Hex value is the above * 16. <br></pre>
</tr>
<tr>
<td align="center"><code>SpPT</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>PS Prochot threshold. Tp0P temp at which Prochot will be asserted</code>
</tr>
<tr>
<td align="center"><code>SpST</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>PS Sleep threshold. Tp0P temp at which Sleep will be requested.</code>
</tr>
<tr>
<td align="center"><code>SpTg</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>PS Fan Temp Target</code>
</tr>
<tr>
<td align="center"><code>TA0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Ambient temp</code>
</tr>
<tr>
<td align="center"><code>TC0D</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 die temp</code>
</tr>
<tr>
<td align="center"><code>TC0H</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 Heatsink temp</code>
</tr>
<tr>
<td align="center"><code>TC0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 Proximity temp</code>
</tr>
<tr>
<td align="center"><code>TG0D</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 die temp</code>
</tr>
<tr>
<td align="center"><code>TG0H</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 Heatsink temp</code>
</tr>
<tr>
<td align="center"><code>TG0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 Proximity temp</code>
</tr>
<tr>
<td align="center"><code>TH0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>HardDisk proximity temp</code>
</tr>
<tr>
<td align="center"><code>TL0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>LCD proximity temp</code>
</tr>
<tr>
<td align="center"><code>TO0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Optical Drive proximity temp</code>
</tr>
<tr>
<td align="center"><code>TW0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Airport temp</code>
</tr>
<tr>
<td align="center"><code>Tm0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Misc Local temp</code>
</tr>
<tr>
<td align="center"><code>Tp0P</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>Power Supply Proximity temp</code>
</tr>
<tr>
<td align="center"><code>UPRC</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_CONST</code>
<td align="left"><code>Type of SMC microcontroller upon which system is based (value of UPROC macro)</code>
</tr>
<tr>
<td align="center"><code>VC0C</code>
<td align="center"><code>fp1f</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 core voltage.</code>
</tr>
<tr>
<td align="center"><code>VC0c</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>CPU 0 core voltage. Raw ADC input value.</code>
</tr>
<tr>
<td align="center"><code>VD0R</code>
<td align="center"><code>fp4c</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC In S0 rail voltage.</code>
</tr>
<tr>
<td align="center"><code>VD5R</code>
<td align="center"><code>fp4c</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>DC In S5 rail voltage.</code>
</tr>
<tr>
<td align="center"><code>VG0R</code>
<td align="center"><code>fp4c</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 rail voltage.</code>
</tr>
<tr>
<td align="center"><code>VG0r</code>
<td align="center"><code>ui16</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_RW</code>
<td align="left"><code>GPU 0 rail voltage. Raw ADC input value.</code>
</tr>
<tr>
<td align="center"><code>dBA0</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Acoustic Reporting. Fan 0 Noise Component (dBA).</code>
</tr>
<tr>
<td align="center"><code>dBA1</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Acoustic Reporting. Fan 1 Noise Component (dBA).</code>
</tr>
<tr>
<td align="center"><code>dBA2</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Acoustic Reporting. Fan 2 Noise Component (dBA).</code>
</tr>
<tr>
<td align="center"><code>dBAH</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Acoustic Reporting. HDD Noise Component (dBDA).</code>
</tr>
<tr>
<td align="center"><code>dBAT</code>
<td align="center"><code>sp78</code>
<td align="center"><code>2</code>
<td align="left"><code>K_VAR_ATOM_R</code>
<td align="left"><code>Acoustic Reporting. Total Noise of all calculated components (dBDA).</code>
</tr>
<tr>
<td align="center"><code>zDBG</code>
<td align="center"><code>ui8</code>
<td align="center"><code>1</code>
<td align="left"><code>K_FUNC_RW</code>
<td align="left"><code>Set this to 1 to enable SCIF debug output to USB 0 Port</code>
</tr>
<tr>
<td align="center"><code>{ala</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>ALS analog lux calculation information.<br>struct ALSLuxLine {<br>   UInt16 ui16ALSM;         // Slope of line.<br>   Int16  i16ALSB;          // Y-Intercept of line.<br>   UInt16 ui16ALSR;         // Region.<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{alc</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>ALSConfig structure contains global ALS configuration and tuning info<br>struct ALSConfig { <br>   UInt16 ui16ALSI2CTime;   // Int interval (ms) for ALS I2C task.<br>   UInt16 ui16ALSADCTime;   // Int interval (ms) for ALS ADC ISR.<br>   UInt16 ui16LMax;         // Maximum cd/m^2 for SIL.<br>   UInt16 ui16LMin;         // Minimum cd/m^2 for SIL.<br>   UInt16 ui16ELow;         // Low room illum threshold (lux).<br>   UInt16 ui16EHigh;        // High room illum threshold (lux).<br>   UInt16 ui16Reflect;      // Bezel reflection coefficient.<br>   UInt8  ui8ALSSensors;    // Actual number of ALS sensors in system.<br>   UInt8  ui8LidDelay;      // Delay after lid opens (in tenths of seconds)<br>                            //   during which ALS readings don't affect the <br>                            //   SIL.<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{ali</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>ALSSensor structure contains sensor-specific information for this system<br>enum ALSType { NoSensor, BS520, TSL2561CS, LX1973A, ISL29003 };<br><br>struct ALSSensor {<br>   enum  ALSType alstALSType;  // Type of sensor.<br>   Flag  fValidWhenLidClosed;  // TRUE if no lid or if sensor works with<br>                               // closed lid.  FALSE otherwise.<br>   Flag  fControlSIL;          // TRUE if the SIL brightness depends on<br>                               // this sensor's value.  FALSE otherwise.<br>}<br> <br></pre>
</tr>
<tr>
<td align="center"><code>{alr</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>ALS analog lux temperature coefficients.<br>struct ALSTherm {<br>   Int16 i16ALSTempBase;    // Temperature baseline (deg C, FP16.0)<br>   UInt16 ui16ALSTempCoefV; // Temperature coeff (ADC Counts/deg C, FP12.4)<br>   UInt16 ui16ALSTempInflV; // Thermal compensation inflection point voltage<br>                            //   (ADCCounts, FP16.0)<br>   Int16 i16ALSTempLow;     // Low temperature boundary (deg C, FP16.0)<br>   Int16 i16ALSTempHigh;    // High temperature boundary (deg C, FP16.0)<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{alt</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>ALS analog lux calculation thresholds.<br>struct ALSLuxThrsh {<br>   UInt16 ui16ALSThrshLow;  // ADC threshold while in low gain.<br>   UInt16 ui16ALSThrshHigh; // ADC threshold while in high gain.<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{alv</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>ALSValue structure contains latest ambient light info from 1 sensor<br>struct ALSValue {<br>   Flag fValid;                    // If TRUE, data in this struct is valid.<br>   Flag fHighGain;                 // If TRUE, ui16Chan0/1 are high-gain<br>                                   // readings.  If FALSE, ui16Chan0/1 are<br>                                   // low-gain readings.<br>   UInt16 ui16Chan0;               // I2C channel 0 data or analog(ADC) data.<br>   UInt16 ui16Chan1;               // I2C channel 1 data.<br> The following field only exists on systems that send ALS change<br> notifications to the OS:<br>   UInt32 ui32RoomLux;             // Room illumination in lux, FP18.14.<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{fds</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>Fan Diag description<br>typedef struct fanTypeDescStruct {<br>   FanType       type;<br>   UInt8         ui8Zone;<br>   LocationType  location;<br>   UChar         rsvd;   // padding to get us to 16 bytes<br>   char          strFunction[DIAG_FUNCTION_STR_LEN];<br>} FanTypeDescStruct;<br><br><br> FAN constants<br><br>      +---+<br>    z/   /|   <br>    /   / |   <br>   +---+  |<br>   |   |  +<br>  y|   | /<br>   |   |/<br>   +---+<br>     x<br>             <br>typedef enum { LEFT_LOWER_FRONT, CENTER_LOWER_FRONT, RIGHT_LOWER_FRONT,<br>               LEFT_MID_FRONT,   CENTER_MID_FRONT,   RIGHT_MID_FRONT,<br>               LEFT_UPPER_FRONT, CENTER_UPPER_FRONT, RIGHT_UPPER_FRONT,<br>               LEFT_LOWER_REAR,  CENTER_LOWER_REAR,  RIGHT_LOWER_REAR,<br>               LEFT_MID_REAR,    CENTER_MID_REAR,    RIGHT_MID_REAR,<br>               LEFT_UPPER_REAR,  CENTER_UPPER_REAR,  RIGHT_UPPER_REAR } LocationType;<br><br>typedef enum { FAN_PWM_TACH, FAN_RPM, PUMP_PWM, PUMP_RPM, FAN_PWM_NOTACH, EMPTY_PLACEHOLDER } FanType; <br><br></pre>
</tr>
<tr>
<td align="center"><code>{lim</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>KPRIV_DESC_STR</code>
<td align="left"><pre>Plimits group is 3 UInt8s:<br> MSB: Cpu Limit<br>      Gpu Limit<br> LSB: Mem Limit<br><br></pre>
</tr>
<tr>
<td align="center"><code>{lsc</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>LmsConfig structure provides overall system-specific config info for the SIL.<br> See "{pwm" for details on PWMValue<br> See "{lsm" for details on LmsScaleMode<br><br>struct LmsConfig {<br>   PWMValue modvBrightnessBreatheMin;     // Breathe dwell PWM setting<br>   PWMValue modvMaxChangePerTick;         // Max PWM change per 1/152 sec<br>   UInt16 ui16ScaleConstant;              // Scale constant (1.15 fixed-point<br>                                          // representation) if not using<br>                                          //   ALS or TOD scaling<br>   LmsScaleMode lmsmScaleMode;            // Scale by ALS, TOD, or constant<br>   UInt8 ui8RampDuration;                 // Ramp length (equals 152 *<br>                                          //   ramp time in seconds)<br>   Flag fPowerSwitchOverridesSIL;         // TRUE if pressing the power<br>                                          //   switch should force the<br>                                          //   SIL to full brightness<br>   UInt8 ui8MinTicksToTarget;             // Slow the slew rate so that<br>                                          //   it takes at least this many<br>                                          //   ticks to reach the target<br>                                          //   from the prev PWM value.<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{lsd</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre> LmsDwell structures provide dwell fade-up/down configuration<br>struct LmsDwell {<br>   UInt16 ui16MidToStartRatio; // Mid-step size / start-step  size<br>   UInt16 ui16MidToEndRatio;   // Mid-step size / end-step    size<br>   UInt16 ui16StartTicks;      // # of ticks using start-step size<br>   UInt16 ui16EndTicks;        // # of ticks using end-step   size<br>}<br><br></pre>
</tr>
<tr>
<td align="center"><code>{lsf</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>LmsFlare structures provide flare config for non-breathing fade-up/down<br> See "{pwm" for details on PWMValue<br><br>struct LmsFlare {<br>   PWMValue modvFlareCeiling;  // Flare algorithm is active below this value.<br>   PWMValue modvMinChange;     // Minimum rate of change while flaring.<br>   UInt16   ui16FlareAdjust;   // Smaller value causes stronger flare as<br>}                              //   PWM value descends below modvFlareCeiling.<br><br></pre>
</tr>
<tr>
<td align="center"><code>{lsm</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>LmsScaleMode enum<br>enum LmsScaleMode { kLmsScaleALS,        // Use ALS autoscale<br>                    kLmsScaleTOD,        // Use TOD autoscale<br>                    kLmsScaleConst       // Scale only by a constant<br>                  }<br><br></pre>
</tr>
<tr>
<td align="center"><code>{lso</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>LmsOverrideBehavior structure provides a means to override the SIL's <br> behavior.<br> See "{lss" for details on LmsSelect<br><br>struct LmsOverrideBehavior {<br>   LmsSelect lmssTargetBehavior;  // Enumerated SIL behavior<br>   Flag fRamp;                    // Set to 1 (LMS_RAMP) for a slew-rate<br>                                  //   controlled transition.  Set to 0<br>                                  //   (LMS_NO_RAMP) for a step change.<br>}<br> <br></pre>
</tr>
<tr>
<td align="center"><code>{lss</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>LmsSelect behavior enum<br>enum LmsSelect { kLmsOff,              // SIL off<br>                 kLmsOn,               // SIL on,        autoscale OK<br>                 kLmsBreathe,          // SIL breathing, autoscale OK<br>                 kLmsBrightNoScale     // SIL on bright, no autoscale<br>                                       //   (for power switch override)<br>               }<br><br></pre>
</tr>
<tr>
<td align="center"><code>{msp</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>SSMPowerState typedef<br> enum SSMPowerState { SSM_POWER_STATE_S0     = 0,<br>                     SSM_POWER_STATE_S3     = 1,<br>                     SSM_POWER_STATE_S4     = 2,<br>                     SSM_POWER_STATE_S5     = 3,<br>                     SSM_POWER_STATE_G3_AC  = 4,<br>                     SSM_POWER_STATE_G3_HOT = 5,<br>                     SSM_POWER_STATE_QUERY  = 6,<br>                   }<br> <br></pre>
</tr>
<tr>
<td align="center"><code>{mss</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>SSMState typedef<br>enum SSMState { SSM_S0_DISP_WAKE        = 0,<br>                SSM_S0_DISP_SLEEP       = 1,<br>                SSM_G3_HOT              = 2,<br>                SSM_S3_SLEEP            = 3,<br>                SSM_S4_HIBER            = 4,<br>                SSM_S5_OFF              = 5,<br>                SSM_S0_ASP_WAIT         = 6,<br>                SSM_S0_IMVP_WAIT        = 7,<br>                SSM_S0_EARLY_DISP_SLEEP = 8,<br>                SSM_S0_EARLY_DISP_WAKE  = 9,<br>                SSM_S3_EARLY            = 10,<br>                SSM_S4_EARLY            = 11,<br>                SSM_QUERY               = 12,<br>                SSM_ICH_RST             = 13,<br>                SSM_G2_BATTERY_DEAD     = 14,<br>                SSM_G2_POWER_WAIT       = 15,<br>                SSM_G2_RESET_WAIT       = 16,<br>                SSM_G3_AC               = 17,<br>                SSM_G2_ACPWR_WAIT       = 18,<br>                SSM_G2_ACRST_WAIT       = 19<br>              }<br> <br></pre>
</tr>
<tr>
<td align="center"><code>{pwm</code>
<td align="center"><code>\0\0\0\0</code>
<td align="center"><code></code>
<td align="left"><code>K_DESC_STR</code>
<td align="left"><pre>PWMValue typedef<br>typedef UInt16 PWMValue;<br>   0xFFFF is full-on, 0x0 is full-off.<br> <br></pre>
</tr>
</table>
</body>
</html>